## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。
3. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。

---

### 二、选择题

4. 函数选择器(selector)的计算方法是: B
   **A)** sha3(函数签名)
   **B)** 函数名哈希的前4字节
   **C)** 函数参数的ABI编码
   **D)** 函数返回值的类型哈希

5. 以下关于mapping的叙述错误的是: C

   **A)** 键类型可以是任意基本类型
   **B)** 值类型支持嵌套mapping
   **C)** 可以通过`length`属性获取大小
   **D)** 无法直接遍历所有键值对

**下面的内容我阅读了文档，但是目前来说很难回答的准确，我应该需要在实战过程中深入理解这些问题**

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

在 Solidity 中，require、assert 和 revert 都用于异常处理，但它们的 触发条件 和 Gas 退还 机制不同：

答：
1. require 一般用于校验，接收两个参数，通过第一个参数判断条件是否成立，成立则进入后续流程，反之则会触发异常并返回第二个参数，同时返回剩余Gas
2. assert 是用于内部报错，常用语检验系统逻辑，防止非法篡改，一旦触发，消耗全部剩余Gas
3. revert 常用于主动触发异常，在逻辑处理中，对于一些场景主动停止合约运行，并反馈，同时返回剩余Gas

7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```
实际执行时会调用哪个父合约的函数？为什么？

答：
由于C继承A、B，所以C的继承顺序是A -> B，在调用继承链上的方法时按照B -> A的顺序查找，所以会先调用B中的foo函数


8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

答：
1. 使用addr.call(),会返回两个值组成的元组，分别是发送结果和bytes，需要手动判断结果，属于低级调用
   优势：没有2300Gas限制
   劣势：需要自行处理结果
2. 使用addr.transfer(), 有gas限制，在交易异常时自动抛出异常，属于安全转账方式
   优势：属于安全转账方式，有异常会自动抛出
   劣势：有Gas限制，不适合复杂合约调用